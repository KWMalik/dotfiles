#!/usr/bin/env python

import os, sys

if not os.name == 'posix':
    warnmsg = """
    This script is meant to run on  linux derivatives.
    Are you sure you want to run this script?
    'y' or enter to continue, otherwise will quit.
    [ENTER to continue]>
    """
    cont = raw_input(warnmsg)
    if cont is not None or cont != 'y':
        if __name__ == '__main__': 
            sys.exit('\nQuitting...\n')
        else:
            raise OSError("Non-posix OS, user elected to stop.")
    else:
        print "OK. Continuing."

def rm_symlink(path, verbose=False):
    """removes file so long as it is a symlink.
    Return  True if removed, False if not."""
    path = os.path.abspath(path)
    if os.path.islink(path):
        os.remove(path)
        return True
    else:
        if verbose: sys.stdout("%r not removed.")
        return False

def symlink_directory(source=None,target=None, filter_fn=None, verbose=True):
    """creates symlinks for all the files in source in directory target.
    INPUT
        source - the directory path default: cwd
        target - the target, required.
        filter_fn - a filter_fn, consider using simpleos.make_filter_fn
            -> default: always true
        note that this function should generally be called only with kwargs
    OUTPUT
        symlinks in path
    RAISES
        ValueError (if no target specified)"""
    if target is None:
        raise ValueError("symlink_directory: target is required. None given. (make sure to use kwargs)")
    else:
        target = os.path.realpath(target)
    source = os.getcwd() if source is None else os.path.abspath(source)
    # create symlink for path
    filter_fn = lambda x: True if filter_fn is None else filter_fn
    filelist = map(lambda x: os.path.join(source,x),filter(filter_fn, os.listdir(source)))
    sym_paths = map(lambda x: os.path.join(target,os.path.basename(x)), filelist)
    msg = "\nsource:  %r\ntarget %r" % (source, target)
    print "The following links will be created(%s)" % msg
    for sym,source in zip(map(os.path.basename,sym_paths),map(os.path.basename,filelist)):
        print "link: %r -> %r" % (sym,source)
    print msg
    if raw_input("\nNOTE: no files will be overwritten.\n[continue? y/n]>") in ['y','yes']:
        for dst,source in zip(sym_paths,filelist):
            try:
                rm_symlink(sym)
                os.symlink(source,dst)
            except OSError as e:
                if 'exists' in e.message or e:
                    print "File exists, not replacing (symlink not added %r)" % (dst)
                    continue
                else:
                    print "OSError:\n%r\nDo you want to continue?" % e.message or e
                    if not raw_input("[Type any key to continue, n or q to quit]>") in ['q','n','quit','no']:
                        continue
                    else:
                        print "Raising error message for reference"
                        raise e
        return
    else:
        return "Ok, not continuing.\nNo files linked.\n"

def main():
    try:
        if len(sys.argv) == 1 or len(sys.argv) == 2:
            raise ValueError("Not enough arguments. Source and target directory are required")
        elif len(sys.argv) == 3:
            source,target = sys.argv[1],sys.argv[2]
        else:
            raise ValueError("Must too many arguments specified at command line")
        if not os.path.isdir(os.path.realpath(target)):
            raise ValueError("Specifed  target path is not a directory.\n Given %r" % target)
        # run program and get output
        output = symlink_directory(source=source,target=target, verbose = False)
    except Exception as e:
        # grab the error message if we can
        msg = e.message if hasattr(e,'message') else 'No message given'
        msg = e if isinstance(e, str) else msg
        msg = """
NB: This script must be called as:
`python <scriptname> source target`
(an additional argument specifying source is optional)
Original error message: 
%r"""  % msg
        raise
        sys.exit(msg)
    sys.exit(output)

if __name__ == '__main__':
    main()
